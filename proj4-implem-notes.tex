\documentclass[11pt,twocolumn]{article}

\usepackage[margin=1in]{geometry}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setlength{\columnsep}{0.25in}

\title{CPE380 Project 4: Pipelined MIPS Processor\\[4pt]
       \large Implementor's Notes}

\author{Michael Naughton and Elijah Gray\\
University of Kentucky, Lexington, KY USA\\
\texttt{mcna226@uky.edu}\\
\texttt{elijah.gray@uky.edu}}

\date{11/24/2025} % no date

\begin{document}

\maketitle

% Main body with two columns

\section*{ABSTRACT}
This project was focused around modifying an existing implementation of a pipelined MIPS processor. The goal was to gain experience with designing pipelined processors by implementing several instructions. We added instructions for the NOR variable shift (sllv,srlv,srav) as well as BNE. We also had to extend the decoder and add ALU functionality.

\section{General Approach}
The first instruction to implement was the MIPS \textbf{nor}, following the format \textbf{nor \$rd, \$rs, \$rt}. This required defining the a new funct field for \textbf{nor}, a new ALU code, a new decode statement for the ID (instruction decode) stage, adding the ALU code to EX (execute) stage, and finally adding a \textbf{\$display} statement for \textbf{nor} to the state-by-state trace. All of these steps were necessary for all of the new instructions. In the EX stage, the output of the ALU was set to equal \textit{$\sim(ID_s | ID_{src})$}.

The \textbf{srlv} and \textbf{srav} instructions were similar to the \textbf{nor} instruction. The only difference being how they were implemented in the ALU during the EX stage. For the \textbf{srlv} instruction it was as simple as using the built in ">>" operator. For \textbf{srav} a conditional had to be introduced. If the most significant bit was a '0', then the shift right operator sufficed. If, however, the MSB was a '1', then the number being shifted had to be sign extended to 64-bits before being shifted.

The \textbf{sllv} instruction required shifting left using the value of the \textbf{rt} register, masked to the lower 5 bits, i.e. \textit{$ID_s << ID_t[4:0]$}. Forwarding and stalling logic had to be accounted for to handle dependencies when the source registers were being written to in previous cycles.

For the \textbf{bne} instruction, branch comparison was performed in the ID stage by checking if \textit{$s \neq t$}. If the branch was taken, the instruction in IF was squashed, and the PC was updated to the branch target. Forwarding also ensured the correct register values were used during branch resolution to prevent hazards.


\section{Issues}

For the \textbf{srav} instruction, the initial solution used involved putting a \textbf{reg} declaration within an \textbf{always} block. This may have worked in SystemVerilog, but is invalid in Verilog.

\end{document}
