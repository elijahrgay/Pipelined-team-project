\documentclass[11pt,twocolumn]{article}

\usepackage[margin=1in]{geometry}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setlength{\columnsep}{0.25in}

\title{CPE380 Project 4: Pipelined MIPS Processor\\[4pt]
       \large Implementor's Notes}

\author{Michael Naughton and Elijah Gray\\
University of Kentucky, Lexington, KY USA\\
\texttt{mcna226@uky.edu}\\
\texttt{elijah.gray@uky.edu}}

\date{11/24/2025} % no date

\begin{document}

\maketitle

% Main body with two columns

\section*{ABSTRACT}
This project was focused around modifying an existing implementation of a pipelined MIPS processor. The goal was to gain experience with designing pipelined processors by implementing several instructions. We added instructions for the NOR variable shift (sllv,srlv,srav) as well as BNE. We also had to extend the decoder and add ALU functionality.

\section{General Approach}
The first instruction to implement was the MIPS \textbf{nor}, following the format \textbf{nor \$rd, \$rs, \$rt}. This required defining the a new funct field for \textbf{nor}, a new ALU code, a new decode statement for the ID (instruction decode) stage, adding the ALU code to EX (execute) stage, and finally adding a \textbf{\$display} statement for \textbf{nor} to the state-by-state trace. All of these steps were necessary for all of the new instructions. In the EX stage, the output of the ALU was set to equal \textit{$\sim(ID_s | ID_{src})$}.

The \textbf{srlv} and \textbf{srav} instructions were similar to the \textbf{nor} instruction. The only difference being how they were implemented in the ALU during the EX stage. For the \textbf{srlv} instruction it was as simple as using the built in ">>" operator. For \textbf{srav} a conditional had to be introduced. If the most significant bit was a '0', then the shift right operator sufficed. If, however, the MSB was a '1', then the number being shifted had to be sign extended to 64-bits before being shifted.

\section{Issues}

For the \textbf{srav} instruction, the initial solution used involved putting a \textbf{reg} declaration within an \textbf{always} block. This may have worked in SystemVerilog, but is invalid in Verilog.

\section{Testing}

For readability, a new statement was added to the beginning of each trace that prints the value in register 4. Most of the tested instructions output to register 4 so that the result of that instruction can be read more easily. The added test cases can be found in \textbf{m[6:0]}. First the \textbf{nor} instruction is tested with the values \textbf{601} and \textbf{11811} which should result in \textbf{r[4] = 4294955396} by the time the PC reaches \textbf{20}.

Next, \textbf{sllv} is tested, shifting \textbf{42} left by \textbf{1} which should result in \textbf{r[4] = 84} immediately after the result from the previous instruction.

Next, \textbf{srlv} is tested, shifting \textbf{88} right by \textbf{1} resulting in \textbf{r[4] = 44}.

Next, \textbf{srav} is tested, first by shifting \textbf{11811} right by \textbf{1} resulting in \textbf{5905}. Then, \textbf{-11769} (or \textbf{4294955527} unsigned) is shifted right by \textbf{1} resulting in \textbf{-5885} or (\textbf{4294961411} unsigned).

Finally, \textbf{bne} is tested by comparing the value stored in \textbf{r[6]} with the value in \textbf{22}. Initially \textbf{r[6] = 88}. If \textbf{r[6] != 22} the program branches back one instruction. The previous instruction halves \textbf{r[6]} and then compares it to /textbf{22} again. Once \textbf{r[6] == 22}, the program continues.

\end{document}
